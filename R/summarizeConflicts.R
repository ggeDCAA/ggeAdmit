#' A function to identify where conflicts of interest exist
# 
# conflictsDF is the conflictsOfInterest dataset (derived from application info)
#'
#' @param assignmentsDF The complete reviewer assignments dataset (as generated by combineOutputs)
#' @param conflictsDF A data.frame() containing conflicts of interest with columns for applicant's "Name" (format "Lastname, Firstname") and "Faculty.Member.1" through "Faculty.Member.6"
#' @return A data.frame() containing one row per reviewer and "Name", "Email" and "Type" columns that indicate reviewer identity, and then "Applicant-1" through "Applicant-i" columns where i is the number of applicants assigned to a single reviewer as defined by `alternatives.per.block` in `assignReviewers()`.
#' @examples
#' \dontrun{
#' complete.design = combineOutputs(reviewers = reviewers,
#' assignments1 = s.des.names,
#' assignments2 = f.des.names)
#' }
#' @export
# 



# A function to identify where conflicts of interest exist
# assignmentsDF is the complete reviewer assignments dataset
# conflictsDF is the conflictsOfInterest dataset (derived from application info)
findConflicts = function(conflictsDF,
                         assignmentsDF){
  # Generate empty COI matrix
  myConflicts = matrix(NA, 
                       nrow = length(unique(conflictsDF$Name)), # Rows = students
                       ncol = 12) # Columns = their specific faculty advisor interests. Should just be 6 but could be 12 if people submitted 2 applications
  for(i in 1:length(unique(conflictsDF$Name))){ # For each unique student...
    student = unique(conflictsDF$Name)[i] # ...find student name
    fullStudentRows = filter(conflictsDF, Name == student) # Isolate that student's row(s) in the GARD data
    fullStudentCOIs = as.vector(as.matrix(fullStudentRows[,2:7])) # Find all COI faculty reviewers
    for(j in 1:length(fullStudentCOIs)){ # For all COI reviewers
      r = fullStudentCOIs[j] # Isolate the reviewer in question
      rAssignments = as.vector(as.matrix(assignmentsDF[assignmentsDF$Name == r,])) # Find all students that reviewer r will review
      if(student %in% rAssignments){ # If the student in question is listed as a reviewee for that COI reviewer,
        myConflicts[i,j] = TRUE # Then we have a conflict of interest!
      }else{
        myConflicts[i,j] = FALSE# Otherwise, no conflict of interest exists.
      } 
    }
  }
  return(myConflicts) # Return matrix of conflicts
}

# Summarize conflicts of Interest
summarizeConflicts = function(COIs, ASSIGNs){
  
  conflictMatrix = findConflicts(conflictsDF = COIs,
                                 assignmentsDF = ASSIGNs)
  # Bad pairs:
  badPairs = which(conflictMatrix == TRUE, arr.ind = TRUE) # Identify where conflict == TRUE
  badPairRevs = matrix(NA, nrow=nrow(badPairs), ncol = 2) # Generate summary matrix that will be filled with applicant-reviewer pairs
  for(i in 1:nrow(badPairs)){
    badapplicant = as.vector(as.matrix(badPairs[i,1]))
    badAppName = as.character(as.matrix(COIs$Name[badapplicant]))
    fullStudentRows = filter(conflictsOfInterest, Name == badAppName) # Isolate that student's row(s) in the GARD data
    fullStudentCOIs = as.vector(as.matrix(fullStudentRows[,2:7])) # Find all COI faculty reviewers
    badreviewer = as.vector(as.matrix(badPairs[i,2]))
    # Assign applicant-reviewer pairs to matrix
    badPairRevs[i,1] = badAppName
    badPairRevs[i,2] = fullStudentCOIs[badreviewer]
  }
  badPairRevs
  badPairsDF = data.frame(badPairRevs)
  names(badPairsDF) = c("Applicant","Reviewer")
  return(badPairsDF)
}

