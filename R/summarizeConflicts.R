#' A function to identify where conflicts of interest exist
#'
#' @param COIs A data.frame() containing conflicts of interest with columns for applicant's "Name" (format "Lastname, Firstname") and "Faculty.Member.1" through "Faculty.Member.6"
#' @param ASSIGNs The complete reviewer assignments dataset (as generated by combineOutputs)
#' @return A data.frame() containing one row per reviewer and "Name", "Email" and "Type" columns that indicate reviewer identity, and then "Applicant-1" through "Applicant-i" columns where i is the number of applicants assigned to a single reviewer as defined by `alternatives.per.block` in `assignReviewers()`.
#' @examples
#' \dontrun{
#' complete.design = combineOutputs(reviewers = reviewers,
#' assignments1 = s.des.names,
#' assignments2 = f.des.names)
#' }
#' @importFrom dplyr filter
#' @export
# 

# Summarize conflicts of Interest
summarizeConflicts = function(COIs, ASSIGNs){
  
  conflictMatrix = findConflicts(conflictsDF = COIs,
                                 assignmentsDF = ASSIGNs)
  # Bad pairs:
  badPairs = which(conflictMatrix == TRUE, arr.ind = TRUE) # Identify where conflict == TRUE
  badPairRevs = matrix(NA, nrow=nrow(badPairs), ncol = 2) # Generate summary matrix that will be filled with applicant-reviewer pairs
  for(i in 1:nrow(badPairs)){
    badapplicant = as.vector(as.matrix(badPairs[i,1]))
    badAppName = as.character(as.matrix(COIs$Name[badapplicant]))
    fullStudentRows = filter(COIs, Name == badAppName) # Isolate that student's row(s) in the GARD data
    fullStudentCOIs = as.vector(as.matrix(fullStudentRows[,2:7])) # Find all COI faculty reviewers
    badreviewer = as.vector(as.matrix(badPairs[i,2]))
    # Assign applicant-reviewer pairs to matrix
    badPairRevs[i,1] = badAppName
    badPairRevs[i,2] = fullStudentCOIs[badreviewer]
  }
  badPairRevs
  badPairsDF = data.frame(badPairRevs)
  names(badPairsDF) = c("Applicant","Reviewer")
  return(badPairsDF)
}

